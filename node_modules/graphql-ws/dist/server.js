"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("uws");
const events_1 = require("events");
const jiff = require("jiff");
const message_type_1 = require("./message-type");
const protocol_1 = require("./protocol");
const isObject = require("lodash.isobject");
const graphql_1 = require("graphql");
const empty_iterable_1 = require("./utils/empty-iterable");
const iterall_1 = require("iterall");
const is_subscriptions_1 = require("./utils/is-subscriptions");
const common_1 = require("./common");
const BinarySender_1 = require("./BinarySender");
class SubscriptionServer {
    static create(options, socketOptions) {
        return new SubscriptionServer(options, socketOptions);
    }
    static sendMessage(connectionContext, opId, type, payload) {
        const message = common_1.buildMessage(opId, type, payload);
        if (connectionContext.socket.readyState === WebSocket.OPEN) {
            connectionContext.socket.send(message);
        }
    }
    static sendError(connectionContext, opId, errorPayload, overrideDefaultErrorType) {
        const sanitizedOverrideDefaultErrorType = overrideDefaultErrorType || message_type_1.MessageType.GQL_ERROR;
        if ([
            message_type_1.MessageType.GQL_CONNECTION_ERROR,
            message_type_1.MessageType.GQL_ERROR,
        ].indexOf(sanitizedOverrideDefaultErrorType) === -1) {
            throw new Error('overrideDefaultErrorType should be one of the allowed error messages' +
                ' GQL_CONNECTION_ERROR or GQL_ERROR');
        }
        SubscriptionServer.sendMessage(connectionContext, opId, sanitizedOverrideDefaultErrorType, errorPayload);
    }
    constructor(options, socketOptions) {
        const { onOperation, onOperationComplete, onConnect, onDisconnect, keepAlive, } = options;
        this.specifiedRules = options.validationRules || graphql_1.specifiedRules;
        this.loadExecutor(options);
        this.onOperation = onOperation;
        this.onOperationComplete = onOperationComplete;
        this.onConnect = onConnect;
        this.onDisconnect = onDisconnect;
        this.keepAlive = keepAlive;
        this.wsServer = new WebSocket.Server(socketOptions || {});
        const connectionHandler = ((socket) => {
            if (socket.upgradeReq.headers['sec-websocket-protocol'] !== protocol_1.GRAPHQL_WS) {
                socket.close(1002);
                return;
            }
            const connectionContext = Object.create(null);
            connectionContext.socket = new common_1.SocketWrapper(socket);
            connectionContext.operations = {};
            connectionContext.filesIn = {};
            connectionContext.filesOut = {};
            connectionContext.filesOutEvent = new events_1.EventEmitter();
            if (this.keepAlive) {
                const keepAliveTimer = setInterval(() => {
                    if (socket.readyState === WebSocket.OPEN) {
                        SubscriptionServer.sendMessage(connectionContext, undefined, message_type_1.MessageType.GQL_CONNECTION_KEEP_ALIVE, undefined);
                    }
                    else {
                        clearInterval(keepAliveTimer);
                    }
                }, this.keepAlive);
            }
            const connectionClosedHandler = (error) => {
                if (error) {
                    SubscriptionServer.sendError(connectionContext, 0, { message: error.message ? error.message : error }, message_type_1.MessageType.GQL_CONNECTION_ERROR);
                    setTimeout(() => {
                        connectionContext.socket.close(1011);
                    }, 10);
                }
                this.onClose(connectionContext);
                if (this.onDisconnect) {
                    this.onDisconnect(socket);
                }
            };
            socket.on('error', connectionClosedHandler);
            socket.on('close', connectionClosedHandler);
            connectionContext.socket.on('message', this.onMessage(connectionContext));
        });
        this.wsServer.on('connection', connectionHandler);
        this.closeHandler = () => {
            this.wsServer.removeListener('connection', connectionHandler);
            this.wsServer.close();
        };
    }
    get server() {
        return this.wsServer;
    }
    close() {
        this.closeHandler();
    }
    loadExecutor(options) {
        const { execute, subscribe, schema, rootValue, formatError } = options;
        if (!execute) {
            throw new Error('Must provide `execute` for websocket server constructor.');
        }
        if (!schema) {
            throw new Error('`schema` is missing');
        }
        this.schema = schema;
        this.rootValue = rootValue;
        this.formatError = formatError;
        this.execute = execute;
        this.subscribe = subscribe;
    }
    unsubscribe(connectionContext, opId) {
        if (connectionContext.operations && connectionContext.operations[opId]) {
            if (connectionContext.operations[opId].return) {
                connectionContext.operations[opId].return();
            }
            delete connectionContext.operations[opId];
            delete connectionContext.filesIn[opId];
            delete connectionContext.filesOut[opId];
            if (this.onOperationComplete) {
                this.onOperationComplete(connectionContext.socket, opId);
            }
        }
    }
    onClose(connectionContext) {
        Object.keys(connectionContext.operations).forEach((opId) => {
            this.unsubscribe(connectionContext, parseInt(opId, 10));
        });
    }
    onMessage(connectionContext) {
        let onInitResolve = null, onInitReject = null;
        connectionContext.initPromise = new Promise((resolve, reject) => {
            onInitResolve = resolve;
            onInitReject = reject;
        });
        return (message) => {
            const parsedMessage = common_1.parseMessage(message);
            if (!parsedMessage) {
                return;
            }
            const opId = parsedMessage.id;
            switch (parsedMessage.type) {
                case message_type_1.MessageType.GQL_CONNECTION_INIT:
                    let onConnectPromise = Promise.resolve(true);
                    if (this.onConnect) {
                        onConnectPromise = new Promise((resolve, reject) => {
                            try {
                                resolve(this.onConnect(parsedMessage.payload, connectionContext.socket, connectionContext));
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                    }
                    onInitResolve(onConnectPromise);
                    connectionContext.initPromise.then((result) => {
                        if (result === false) {
                            throw new Error('Prohibited connection!');
                        }
                        SubscriptionServer.sendMessage(connectionContext, undefined, message_type_1.MessageType.GQL_CONNECTION_ACK, undefined);
                        if (this.keepAlive) {
                            SubscriptionServer.sendMessage(connectionContext, undefined, message_type_1.MessageType.GQL_CONNECTION_KEEP_ALIVE, undefined);
                        }
                    }).catch((error) => {
                        SubscriptionServer.sendError(connectionContext, opId, { message: error.message }, message_type_1.MessageType.GQL_CONNECTION_ERROR);
                        setTimeout(() => {
                            connectionContext.socket.close(1011);
                        }, 10);
                    });
                    break;
                case message_type_1.MessageType.GQL_CONNECTION_TERMINATE:
                    connectionContext.socket.close();
                    break;
                case message_type_1.MessageType.GQL_START:
                    connectionContext.initPromise.then((initResult) => {
                        if (connectionContext.operations && connectionContext.operations[opId]) {
                            this.unsubscribe(connectionContext, opId);
                        }
                        const payload = parsedMessage.payload;
                        const baseParams = {
                            query: payload.query,
                            variables: payload.variables,
                            operationName: payload.operationName,
                            context: Object.assign({}, isObject(initResult) ? initResult : {}),
                            formatResponse: undefined,
                            formatError: undefined,
                            callback: undefined,
                        };
                        let promisedParams = Promise.resolve(baseParams);
                        connectionContext.operations[opId] = empty_iterable_1.createEmptyIterable();
                        connectionContext.filesIn[opId] = [];
                        connectionContext.filesOut[opId] = [];
                        if (this.onOperation) {
                            let messageForCallback = parsedMessage;
                            promisedParams = Promise.resolve(this.onOperation(messageForCallback, baseParams, connectionContext.socket));
                        }
                        promisedParams.then((params) => {
                            if (typeof params !== 'object') {
                                const error = `Invalid params returned from onOperation! return values must be an object!`;
                                SubscriptionServer.sendError(connectionContext, opId, { message: error });
                                throw new Error(error);
                            }
                            const document = typeof baseParams.query !== 'string' ? baseParams.query : graphql_1.parse(baseParams.query);
                            let executionPromise;
                            const validationErrors = graphql_1.validate(this.schema, document, this.specifiedRules);
                            if (validationErrors.length > 0) {
                                executionPromise = Promise.resolve({ errors: validationErrors });
                            }
                            else {
                                let executor = this.execute;
                                if (this.subscribe && is_subscriptions_1.isASubscriptionOperation(document, params.operationName)) {
                                    executor = this.subscribe;
                                }
                                connectionContext.filesIn[opId] = common_1.extractIncomingFiles(opId, connectionContext.socket, params.variables);
                                executionPromise = Promise.resolve(executor(this.schema, document, this.rootValue, params.context, params.variables, params.operationName));
                            }
                            return executionPromise.then((executionResult) => ({
                                executionIterable: iterall_1.isAsyncIterable(executionResult) ?
                                    executionResult : iterall_1.createAsyncIterator([executionResult]),
                                params,
                            }));
                        }).then(({ executionIterable, params }) => {
                            let lastVal;
                            iterall_1.forAwaitEach(executionIterable, (value) => {
                                let result = value;
                                connectionContext.filesOut[opId] = common_1.extractOutgoingFiles(result.data);
                                if (params.formatResponse) {
                                    try {
                                        result = params.formatResponse(value, params);
                                    }
                                    catch (err) {
                                        console.error('Error in formatError function:', err);
                                    }
                                }
                                if (lastVal) {
                                    result = { data: { __patch: jiff.diff(lastVal.data, value.data, { invertible: false }) } };
                                }
                                else {
                                    result = value;
                                }
                                lastVal = value;
                                SubscriptionServer.sendMessage(connectionContext, opId, message_type_1.MessageType.GQL_DATA, result);
                            }).then(() => __awaiter(this, void 0, void 0, function* () {
                                while (connectionContext.filesOut[opId] && connectionContext.filesOut[opId].length > 0) {
                                    yield new Promise(resolve => connectionContext.filesOutEvent.once(opId.toString(), resolve));
                                }
                            }))
                                .then(() => {
                                SubscriptionServer.sendMessage(connectionContext, opId, message_type_1.MessageType.GQL_COMPLETE, null);
                                this.unsubscribe(connectionContext, opId);
                            })
                                .catch((e) => {
                                let error = e;
                                if (params.formatError) {
                                    try {
                                        error = params.formatError(e, params);
                                    }
                                    catch (err) {
                                        console.error('Error in formatError function: ', err);
                                    }
                                }
                                if (Object.keys(e).length === 0) {
                                    error = { name: e.name, message: e.message };
                                }
                                SubscriptionServer.sendError(connectionContext, opId, error);
                            });
                            return executionIterable;
                        }).then((subscription) => {
                            connectionContext.operations[opId] = subscription;
                        }).then(() => {
                        }).catch((e) => {
                            if (e.errors) {
                                SubscriptionServer.sendMessage(connectionContext, opId, message_type_1.MessageType.GQL_DATA, { errors: e.errors });
                            }
                            else {
                                SubscriptionServer.sendError(connectionContext, opId, { message: e.message });
                            }
                            this.unsubscribe(connectionContext, opId);
                            return;
                        });
                    });
                    break;
                case message_type_1.MessageType.GQL_BINARY_REQUEST:
                    connectionContext.initPromise.then(() => __awaiter(this, void 0, void 0, function* () {
                        const payload = parsedMessage.payload;
                        if (connectionContext.filesOut[opId]) {
                            const { id, offset } = payload;
                            const file = connectionContext.filesOut[opId].find(f => f.getId() === id);
                            if (file) {
                                const reader = file.createReadStream(offset);
                                const writer = new BinarySender_1.BinarySender({
                                    opId,
                                    fileId: file.getId(),
                                    socket: connectionContext.socket,
                                });
                                const finish = new Promise((resolve, reject) => {
                                    reader.pipe(writer)
                                        .on('finish', resolve)
                                        .on('error', reject);
                                });
                                yield finish;
                                if (connectionContext.filesOut[opId]) {
                                    const index = connectionContext.filesOut[opId].findIndex(f => f === file);
                                    delete connectionContext.filesOut[opId][index];
                                    connectionContext.filesOutEvent.emit(opId.toString());
                                }
                            }
                        }
                    }));
                    break;
                case message_type_1.MessageType.GQL_STOP:
                    connectionContext.initPromise.then(() => {
                        this.unsubscribe(connectionContext, opId);
                    });
                    break;
                default:
                    break;
            }
        };
    }
}
exports.SubscriptionServer = SubscriptionServer;
//# sourceMappingURL=server.js.map