"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Binary_1 = require("./Binary");
const BinaryReceiver_1 = require("./BinaryReceiver");
const message_type_1 = require("./message-type");
const events_1 = require("events");
class SocketWrapper {
    constructor(socket) {
        this.events = new events_1.EventEmitter();
        this.socket = socket;
        this.socket.on('message', this.onMessage.bind(this));
    }
    send(data, cb) {
        this.socket.send(data, cb);
    }
    get readyState() {
        return this.socket.readyState;
    }
    close(code, data) {
        this.socket.close(code, data);
    }
    getSocket() {
        return this.socket;
    }
    on(event, cb) {
        this.events.on('message', cb);
        return this;
    }
    once(event, cb) {
        this.events.once('message', cb);
        return this;
    }
    removeListener(event, cb) {
        this.events.removeListener('message', cb);
        return this;
    }
    removeEventListener(event, cb) {
        this.events.removeListener('message', cb);
        return this;
    }
    onMessage(message) {
        this.events.emit('message', message);
    }
}
exports.SocketWrapper = SocketWrapper;
function repeatPromise(promise) {
    return promise().then((repeat) => repeat && repeatPromise(promise));
}
exports.repeatPromise = repeatPromise;
function findBinaries(object) {
    const value = [];
    Object.keys(object || {}).forEach((k) => {
        if (object[k] instanceof Binary_1.Binary) {
            value.push(object[k]);
        }
        else if (object[k] && typeof object[k] === 'object') {
            value.push(...findBinaries(object[k]));
        }
    });
    return value;
}
function deserializeBinaries(object, callback) {
    Object.keys(object).forEach((k) => {
        if (Binary_1.Binary.isBinary(object[k])) {
            object[k] = callback(object[k]);
        }
        else if (object[k] && typeof object[k] === 'object') {
            deserializeBinaries(object[k], callback);
        }
    });
}
function extractIncomingFiles(opId, socket, obj) {
    const files = [];
    deserializeBinaries(obj || {}, (file) => {
        const onStream = (offset) => new BinaryReceiver_1.BinaryReceiver({
            opId,
            fileId: file.id,
            offset,
            socket,
        });
        const binary = new Binary_1.Binary(onStream, file);
        const found = files.find(f => f.equal(binary));
        if (found) {
            binary.clone(found);
        }
        else {
            files.push(binary);
        }
        return binary;
    });
    return files;
}
exports.extractIncomingFiles = extractIncomingFiles;
function extractOutgoingFiles(obj) {
    const files = [];
    for (let file of findBinaries(obj || {})) {
        const found = files.find(f => f.equal(file));
        if (found) {
            file.clone(found);
        }
        else {
            files.push(file);
        }
    }
    return files;
}
exports.extractOutgoingFiles = extractOutgoingFiles;
function parseMessage(buffer) {
    const message = Buffer.from(buffer);
    let result;
    let payloadBase = {
        id: message.readUInt32LE(0),
        type: message.readUInt32LE(4),
    };
    if (payloadBase.type === message_type_1.MessageType.GQL_BINARY_REQUEST) {
        const payload = {
            id: message.readUInt32LE(8),
            offset: message.readUInt32LE(12),
        };
        result = Object.assign({}, payloadBase, { payload });
    }
    else {
        const availableTypes = [
            message_type_1.MessageType.GQL_CONNECTION_INIT,
            message_type_1.MessageType.GQL_START,
            message_type_1.MessageType.GQL_STOP,
            message_type_1.MessageType.GQL_CONNECTION_TERMINATE,
            message_type_1.MessageType.GQL_CONNECTION_ERROR,
            message_type_1.MessageType.GQL_CONNECTION_ACK,
            message_type_1.MessageType.GQL_COMPLETE,
            message_type_1.MessageType.GQL_ERROR,
            message_type_1.MessageType.GQL_DATA,
            message_type_1.MessageType.GQL_CONNECTION_KEEP_ALIVE,
        ];
        if (availableTypes.includes(payloadBase.type)) {
            const payloadStr = Buffer.from(buffer, 8).toString();
            const payload = payloadStr.length > 0 ? JSON.parse(payloadStr) : null;
            result = Object.assign({}, payloadBase, { payload });
        }
    }
    return result;
}
exports.parseMessage = parseMessage;
function buildMessage(id, type, payload) {
    const serializedMessage = Buffer.from(JSON.stringify(payload) || '');
    const headerSize = 8;
    const message = new Buffer(headerSize + serializedMessage.length);
    message.writeUInt32LE(id, 0);
    message.writeUInt32LE(type, 4);
    serializedMessage.copy(message, headerSize);
    return message.buffer;
}
exports.buildMessage = buildMessage;
//# sourceMappingURL=common.js.map