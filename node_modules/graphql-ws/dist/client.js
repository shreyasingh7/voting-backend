"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});
const NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
const Backoff = require("backo2");
const eventemitter3_1 = require("eventemitter3");
const isString = require("lodash.isstring");
const isObject = require("lodash.isobject");
const getOperationAST_1 = require("graphql/utilities/getOperationAST");
const symbol_observable_1 = require("symbol-observable");
const protocol_1 = require("./protocol");
const defaults_1 = require("./defaults");
const message_type_1 = require("./message-type");
const Binary_1 = require("./Binary");
exports.Binary = Binary_1.Binary;
const BinarySender_1 = require("./BinarySender");
const common_1 = require("./common");
var readable_stream_1 = require("readable-stream");
exports.Readable = readable_stream_1.Readable;
exports.Writable = readable_stream_1.Writable;
exports.Buffer = readable_stream_1.Buffer;
class SubscriptionClient {
    constructor(url, options, webSocketImpl) {
        const { connectionCallback = undefined, connectionParams = {}, timeout = defaults_1.WS_TIMEOUT, reconnect = false, reconnectionAttempts = Infinity, lazy = false, } = (options || {});
        this.wsImpl = webSocketImpl || NativeWebSocket;
        if (!this.wsImpl) {
            throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');
        }
        this.connectionParams = connectionParams;
        this.connectionCallback = connectionCallback;
        this.url = url;
        this.operations = {};
        this.filesOut = [];
        this.filesIn = [];
        this.nextOperationId = 0;
        this.wsTimeout = timeout;
        this.unsentMessagesQueue = [];
        this.reconnect = reconnect;
        this.reconnecting = false;
        this.reconnectionAttempts = reconnectionAttempts;
        this.lazy = !!lazy;
        this.closedByUser = false;
        this.backoff = new Backoff({ jitter: 0.5 });
        this.eventEmitter = new eventemitter3_1.EventEmitter();
        this.middlewares = [];
        this.client = null;
        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
        if (!this.lazy) {
            this.connect();
        }
    }
    get status() {
        if (this.client === null) {
            return this.wsImpl.CLOSED;
        }
        return this.client.readyState;
    }
    close(isForced = true, closedByUser = true) {
        if (this.client !== null) {
            this.closedByUser = closedByUser;
            if (isForced) {
                this.clearCheckConnectionInterval();
                this.clearMaxConnectTimeout();
                this.clearTryReconnectTimeout();
                this.unsubscribeAll();
                this.sendMessage(undefined, message_type_1.MessageType.GQL_CONNECTION_TERMINATE, null);
            }
            this.client.close();
            this.client = null;
            this.eventEmitter.emit('disconnected');
            if (!isForced) {
                this.tryReconnect();
            }
        }
    }
    request(request) {
        const getObserver = this.getObserver.bind(this);
        const executeOperation = this.executeOperation.bind(this);
        const unsubscribe = this.unsubscribe.bind(this);
        let opId;
        return {
            [symbol_observable_1.default]() {
                return this;
            },
            subscribe(observerOrNext, onError, onComplete) {
                const observer = getObserver(observerOrNext, onError, onComplete);
                opId = executeOperation(request, (error, result) => {
                    if (error === null && result === null) {
                        if (observer.complete) {
                            observer.complete();
                        }
                    }
                    else if (error) {
                        if (observer.error) {
                            observer.error(error[0]);
                        }
                    }
                    else {
                        if (observer.next) {
                            observer.next(result);
                        }
                    }
                });
                return {
                    unsubscribe: () => {
                        if (opId) {
                            unsubscribe(opId);
                            opId = null;
                        }
                    },
                };
            },
        };
    }
    on(eventName, callback, context) {
        const handler = this.eventEmitter.on(eventName, callback, context);
        return () => {
            handler.off(eventName, callback, context);
        };
    }
    onConnected(callback, context) {
        return this.on('connected', callback, context);
    }
    onConnecting(callback, context) {
        return this.on('connecting', callback, context);
    }
    onDisconnected(callback, context) {
        return this.on('disconnected', callback, context);
    }
    onReconnected(callback, context) {
        return this.on('reconnected', callback, context);
    }
    onReconnecting(callback, context) {
        return this.on('reconnecting', callback, context);
    }
    unsubscribeAll() {
        Object.keys(this.operations).forEach(subId => {
            this.unsubscribe(parseInt(subId, 10));
        });
    }
    applyMiddlewares(options) {
        return new Promise((resolve, reject) => {
            const queue = (funcs, scope) => {
                const next = (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        if (funcs.length > 0) {
                            const f = funcs.shift();
                            if (f) {
                                f.applyMiddleware.apply(scope, [options, next]);
                            }
                        }
                        else {
                            resolve(options);
                        }
                    }
                };
                next();
            };
            queue([...this.middlewares], this);
        });
    }
    use(middlewares) {
        middlewares.map((middleware) => {
            if (typeof middleware.applyMiddleware === 'function') {
                this.middlewares.push(middleware);
            }
            else {
                throw new Error('Middleware must implement the applyMiddleware function.');
            }
        });
        return this;
    }
    executeOperation(options, handler) {
        if (this.client === null) {
            this.connect();
        }
        const opId = this.generateOperationId();
        this.operations[opId] = { options: options, handler };
        this.filesIn[opId] = [];
        this.filesOut[opId] = [];
        this.applyMiddlewares(options)
            .then((processedOptions) => __awaiter(this, void 0, void 0, function* () {
            this.checkOperationOptions(processedOptions, handler);
            this.filesOut[opId] = common_1.extractOutgoingFiles(processedOptions.variables);
            if (this.operations[opId]) {
                this.operations[opId] = { options: processedOptions, handler };
                this.sendMessage(opId, message_type_1.MessageType.GQL_START, processedOptions);
            }
        }))
            .catch(error => {
            this.unsubscribe(opId);
            handler(this.formatErrors(error));
        });
        return opId;
    }
    getObserver(observerOrNext, error, complete) {
        if (typeof observerOrNext === 'function') {
            return {
                next: (v) => observerOrNext(v),
                error: (e) => error && error(e),
                complete: () => complete && complete(),
            };
        }
        return observerOrNext;
    }
    createMaxConnectTimeGenerator() {
        const minValue = 1000;
        const maxValue = this.wsTimeout;
        return new Backoff({
            min: minValue,
            max: maxValue,
            factor: 1.2,
        });
    }
    clearCheckConnectionInterval() {
        if (this.checkConnectionIntervalId) {
            clearInterval(this.checkConnectionIntervalId);
            this.checkConnectionIntervalId = null;
        }
    }
    clearMaxConnectTimeout() {
        if (this.maxConnectTimeoutId) {
            clearTimeout(this.maxConnectTimeoutId);
            this.maxConnectTimeoutId = null;
        }
    }
    clearTryReconnectTimeout() {
        if (this.tryReconnectTimeoutId) {
            clearTimeout(this.tryReconnectTimeoutId);
            this.tryReconnectTimeoutId = null;
        }
    }
    checkOperationOptions(options, handler) {
        const { query, variables, operationName } = options;
        if (!query) {
            throw new Error('Must provide a query.');
        }
        if (!handler) {
            throw new Error('Must provide an handler.');
        }
        if ((!isString(query) && !getOperationAST_1.getOperationAST(query, operationName)) ||
            (operationName && !isString(operationName)) ||
            (variables && !isObject(variables))) {
            throw new Error('Incorrect option types. query must be a string or a document,' +
                '`operationName` must be a string, and `variables` must be an object.');
        }
    }
    formatErrors(errors) {
        if (Array.isArray(errors)) {
            return errors;
        }
        if (errors && errors.errors) {
            return this.formatErrors(errors.errors);
        }
        if (errors && errors.message) {
            return [errors];
        }
        return [{
                name: 'FormatedError',
                message: 'Unknown error',
                originalError: errors,
            }];
    }
    sendMessage(id, type, payload) {
        this.sendMessageRaw(common_1.buildMessage(id, type, payload));
    }
    sendMessageRaw(message) {
        switch (this.status) {
            case this.wsImpl.OPEN:
                this.client.send(message);
                break;
            case this.wsImpl.CONNECTING:
                this.unsentMessagesQueue.push(message);
                break;
            default:
                if (!this.reconnecting) {
                    throw new Error('A message was not sent because socket is not connected, is closing or ' +
                        'is already closed. ');
                }
        }
    }
    generateOperationId() {
        return ++this.nextOperationId;
    }
    tryReconnect() {
        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
            return;
        }
        if (!this.reconnecting) {
            Object.keys(this.operations).forEach((key) => {
                const opId = parseInt(key, 10);
                this.unsentMessagesQueue.push(common_1.buildMessage(opId, message_type_1.MessageType.GQL_START, this.operations[opId].options));
            });
            this.reconnecting = true;
        }
        this.clearTryReconnectTimeout();
        const delay = this.backoff.duration();
        this.tryReconnectTimeoutId = setTimeout(() => {
            this.connect();
        }, delay);
    }
    flushUnsentMessagesQueue() {
        this.unsentMessagesQueue.forEach((message) => {
            this.sendMessageRaw(message);
        });
        this.unsentMessagesQueue = [];
    }
    checkConnection() {
        if (this.wasKeepAliveReceived) {
            this.wasKeepAliveReceived = false;
            return;
        }
        if (!this.reconnecting) {
            this.close(false, true);
        }
    }
    checkMaxConnectTimeout() {
        this.clearMaxConnectTimeout();
        this.maxConnectTimeoutId = setTimeout(() => {
            if (this.status !== this.wsImpl.OPEN) {
                this.close(false, true);
            }
        }, this.maxConnectTimeGenerator.duration());
    }
    patchSocket(socket) {
        if (socket.addEventListener) {
            socket.on = (event, cb) => socket.addEventListener(event, ({ data }) => cb(data));
        }
        const sockSend = socket.send.bind(socket);
        socket.send = (data, callback) => {
            try {
                sockSend(data);
                if (callback) {
                    callback();
                }
            }
            catch (err) {
                if (callback) {
                    callback(err);
                }
                else {
                    throw err;
                }
            }
        };
    }
    connect() {
        const socket = new this.wsImpl(this.url, protocol_1.GRAPHQL_WS);
        this.patchSocket(socket);
        this.client = new common_1.SocketWrapper(socket);
        this.client.getSocket().binaryType = 'arraybuffer';
        this.checkMaxConnectTimeout();
        this.client.getSocket().onopen = () => {
            this.clearMaxConnectTimeout();
            this.closedByUser = false;
            this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');
            const payload = typeof this.connectionParams === 'function' ? this.connectionParams() : this.connectionParams;
            this.sendMessage(undefined, message_type_1.MessageType.GQL_CONNECTION_INIT, payload);
            this.flushUnsentMessagesQueue();
        };
        this.client.getSocket().onclose = () => {
            if (!this.closedByUser) {
                this.close(false, false);
            }
        };
        this.client.getSocket().onerror = () => {
        };
        this.client.on('message', (data) => {
            this.processReceivedData(data);
        });
    }
    processReceivedData(receivedData) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedMessage = common_1.parseMessage(receivedData);
            if (!parsedMessage) {
                return;
            }
            const opId = parsedMessage.id;
            if ([
                message_type_1.MessageType.GQL_DATA,
                message_type_1.MessageType.GQL_BINARY,
                message_type_1.MessageType.GQL_BINARY_ACK,
                message_type_1.MessageType.GQL_BINARY_REQUEST,
                message_type_1.MessageType.GQL_ERROR,
                message_type_1.MessageType.GQL_COMPLETE,
            ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
                this.unsubscribe(opId);
                return;
            }
            switch (parsedMessage.type) {
                case message_type_1.MessageType.GQL_CONNECTION_ERROR:
                    if (this.connectionCallback) {
                        this.connectionCallback(parsedMessage.payload);
                    }
                    break;
                case message_type_1.MessageType.GQL_CONNECTION_ACK:
                    this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected');
                    this.reconnecting = false;
                    this.backoff.reset();
                    this.maxConnectTimeGenerator.reset();
                    if (this.connectionCallback) {
                        this.connectionCallback();
                    }
                    break;
                case message_type_1.MessageType.GQL_COMPLETE:
                    this.operations[opId].handler(null, null);
                    delete this.operations[opId];
                    delete this.filesOut[opId];
                    break;
                case message_type_1.MessageType.GQL_ERROR:
                    this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
                    delete this.operations[opId];
                    break;
                case message_type_1.MessageType.GQL_DATA: {
                    const parsedPayload = !parsedMessage.payload.errors ?
                        parsedMessage.payload : Object.assign({}, parsedMessage.payload, { errors: this.formatErrors(parsedMessage.payload.errors) });
                    this.filesIn[opId] = common_1.extractIncomingFiles(opId, this.client, parsedPayload);
                    this.operations[opId].handler(null, parsedPayload);
                    break;
                }
                case message_type_1.MessageType.GQL_BINARY_REQUEST: {
                    const payload = parsedMessage.payload;
                    if (this.filesOut[opId]) {
                        const { id, offset } = payload;
                        const file = this.filesOut[opId].find(f => f.getId() === id);
                        if (file) {
                            const reader = file.createReadStream(offset);
                            const writer = new BinarySender_1.BinarySender({
                                opId,
                                fileId: file.getId(),
                                socket: this.client,
                            });
                            const finish = new Promise((resolve, reject) => {
                                reader.pipe(writer)
                                    .on('finish', resolve)
                                    .on('error', reject);
                            });
                            yield finish;
                            if (this.filesOut[opId]) {
                                const index = this.filesOut[opId].findIndex(f => f === file);
                                delete this.filesOut[opId][index];
                            }
                        }
                    }
                    break;
                }
                case message_type_1.MessageType.GQL_CONNECTION_KEEP_ALIVE:
                    const firstKA = typeof this.wasKeepAliveReceived === 'undefined';
                    this.wasKeepAliveReceived = true;
                    if (firstKA) {
                        this.checkConnection();
                    }
                    if (this.checkConnectionIntervalId) {
                        clearInterval(this.checkConnectionIntervalId);
                        this.checkConnection();
                    }
                    this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
                    break;
                default:
                    throw new Error('Invalid message type!');
            }
        });
    }
    unsubscribe(opId) {
        if (this.operations[opId]) {
            delete this.operations[opId];
            this.sendMessage(opId, message_type_1.MessageType.GQL_STOP, undefined);
        }
    }
}
exports.SubscriptionClient = SubscriptionClient;
//# sourceMappingURL=client.js.map